<style type="text/css">
center{
	direction: rtl;
}
	
h2{
	direction: rtl;
}
	#content{

		direction: rtl;
	}
	pre{


		padding: 8px 0 12px 20px;
border-left: 4px solid #566D82;
margin-bottom: 1.25em;
background: #0F192A;
color:white;
}
	}
</style>

<body>
<h2>فۇنكىسيە</h2>
<p id="content">
	فۇنكىسيە javascript دا تۇنجى تۈر ئوبيكىتى ھىسابلىنىدۇ،بۇ دىگەنلىك فۇنكىيسەنى باشقا فۇنكسيەلەرگە پارامىتىر شەكلىدە ئۆتكۈزگىلى بولىدۇ،ئادەتتە بۇخىل ئىشلىتىلىش نامسىز فۇنكىيسەنى callback شەكىلدە ئۆتكۈزۈش دەپ ئاتىلىدۇ
</p>
<p id="content">
	فۇنكىسيەنى ئىنىقلاش ئۇسۇلى
</p>
<pre>
	
	function foo() {}
</pre>
<p id="content">
ئۈستىدكى كود پىروگىرامما باشلىنىپ ئىجرا قىلىنشتىن بۇرۇن ئۆزى ئىنىقلانغان ھەرقانداق دائىر ئىچىدە كۈچكە ئىگە ،ئەگەر بىزبۇنى  ھەقيقى ئىنقلاشتىن بۇرۇن چاقىرساقمۇ يەنىلا ئوخشاش خىزمەت قىلىۋىرىدۇ

</p>
<pre>
	foo(); // Works because foo was created before this code runs
function foo() {}
</pre>
<p id="content">
	
	ئىپادىلەش فۇنكىسيەسى
	</br>
بۇخىل فۇنكىسيەدە بىز نامسىزفۇنكىسيەنى مىقدار fooغا تەقسىملەپ بىرىمىز
</p>
<pre>
foo; // 'undefined'
foo(); // this raises a TypeError
var foo = function() {};
</pre>
<p id="content">
var مىقدار ئىنىقلاش ئاچقۇچى بولغاچقا ھەقىقى كود ئىجرا بولۇشتىن foo ئىجرا بولىدۇ
چۈنكى تەقسىملەش پەقەت ئىجرا مۇھىتىدىلا پەيدا بولىدۇ،fooنىڭ قىممىتى ماس كود ئىجرابولۇشتىن بۇرۇن ئەسلىدىنلا undefined يەنى ئىنىقلانمىغان بولىدۇ
</p>
<p id="content">
	ئىسملىق فۇنكىسيە ئىپادىلەش
	</br>
فۇنكىسيەنىڭ باشقىچە بىرخىل ئىپادىلەش ئۇسۇلى
</p>
<pre>
var foo = function bar() {
    bar(); // Works
}
bar(); // ReferenceError	

</pre>
<p id="content">
	this نىڭ ئالاھىدىلىكى
	</br>
	javascript دىكى this ھالقىلىق سۆزىنىڭ باشقا پىروگىرامما تىلرىىدىكى this قا قارىغاندا باشقىچە ئۇقۇمى بار
	Javscript دىكى this نىڭ باشقا پىروگىرامما تىللىرىغا قارىغاندا 5 خىل ئوخشىماسلىق بار
</p>
<p id="content">
	ئومۇمى دائىرلىك يەنى (global)  دائىرە
	</br>
	this ئومۇمى دائىرە(global)دائىرىسىدە ئىشلىتىلگەندە ئومۇمى دائىرلىك ئوبيكىتقا ئىشارەت قىلىدۇ
</p>
<p id="content">
	فۇنكىسيەنى چاقىرىش
</p>
<pre>
foo();	
</pre>
<p id="content">
	مىتودنى چاقرىش(يەنى ھەرىكەت)

</p>
<pre>
	test.foo(); 
</pre>
<p id="content">
	بۇ مىسالدا thisنىڭ ئىشارەت قىلىدىغىنى test()بولىدۇ
</p>
<p id="content">

	قۇرۇلمىلىك فۇنكىسيە
</p>
<pre>
	new foo(); 
</pre>
<p id="content">
	فۇنكىسيە new ھالقىلىق سۆزى بىلەن چاقىرىلسا بۇ قۇرۇلمىلىق فۇنكىسيە بولىدۇ.بۇۋاقىتتا قۇرۇلمىلىق فۇنكىسيەنىڭ ئىچىدىكى this يىڭىدىن قۇرۇلغان ئوبيكىتقا ئىشارەت قىلىدۇ
</p>
<pre>
function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // array will expand to the below
foo.call(bar, 1, 2, 3); // results in a = 1, b = 2, c = 3	
</pre>
<p id="content">
Function.prototype نىڭ مىتودى applyۋە callئىشلىتىلگەن ۋاقىتتا,چاقىرىلغان فۇنكىسيەنىڭ ئىچىدىكى this نىڭ قىممىتى ئوچۇق ئاشكارا ھالدا،ماس كىلىدىغان فۇنكىسيە چاقىرىقىنىڭ بىرىنجى پارامىتىرغا تەڭشىلىدۇ	
</p>
<p id="content">
ئورتاق خاتالىق	
</br>
گەرچە قارىماققا مەنىسى باردەك قىلسىمۇ ئەمما ،باشقا بىرخاتا لايھەلەنگەن تىل دەپ قاراشقا بولىدۇ،(دىمەكچىمەنكى javascript نىڭ ئازراق كەمچىلىكلىرى بار)
</p>
<p id="content">
	دائىملىق بىر خاتالىق test نىڭ ئىچىدىكى this نىڭ foo غا ئىشارەت قىلىشىدۇر،ئەمىليەتتە ئۇنداق ئەمەس!
	</br>
	test نىڭ ئىچىدىن foo غا كىرىش ئۈچۈن،foo غا ئىشارەت قىلىدىغان مىتودنىڭ ئىچىدە يەرلىك ئۆزگەرگۈچى مىقدار قۇرۇش كىرەك
</p>
<pre>
Foo.method = function() {
    var that = this;
    function test() {
        // Use that instead of this here
    }
    test();
}	
</pre>
<p id="content">
that نورمال ئۆزگەرگۈچى مىقدار نامى،بىراق ھەمىشە بۇ سىرتقى this قا قوللانما قىلىشقا ئىشلىتىلىدۇ
</br>
مىتودنى تەقسىملەش
</br>
javascript دا ئىشلىمەيدىغان يەنە بىرنەرسە بولسا مىتودنى ئۆزگەرگۈچى مىقدارغا تەقسىملەش
</p>
<pre>
var test = someObject.methodTest;
test();	
</pre>
<p id="content">
بۇ ئەھۋالدا test()ئاددى فۇنكىسيە چاقىرىقىغا ئوخشاش ئىپادە بىلدۈرىدۇ،شۇڭلاشقا ئىچىدكى this ھالقىلىق سۆزى someobject قا ئىشارەت قىلالالمايدۇ	
</p>
<hr></hr>
<p id="content">
ئاخىرلاشتۇرۇش ۋە قوللانما(reference)
</br>
javascript نىڭ ئەڭ كۈچلۈك ئىقتىدارىنىڭ بىرى ئۇنىڭ ئاخىرلاشتۇرۇش(يەنى چەك دائىرىسنى بىكىتىش )ئىقتىدارىنىڭ بولغانلىقىدۇر،دائىرە يەنى(scope)ئۆزى ئىنىقلانغان دائىرىدە ئچىىدە سىرتقى دائىرە(scope)غا كىرىشنى ساقلاپ قالىدۇ،
javascript دا فۇننكىسيەنى دائىرىسى بولۇپ،ئەسلدىىنلا ھەممە فۇنكىسيە closure (يەنى ئاخىرلاشتۇرۇش،چىگىراسىنى بەلگىلەشكە)ئوخشاش خۇسۇسىيتى بار	
</p>
<hr></hr>
<p id="content">
	خۇسۇسى مىقدارنى تەقلىدلەش

</p>
<pre>
function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5	
</pre>
<p id="content">
بۇ كودتا Counter دائىرە closure (يەنى چەك دائىرىسى)بولغان ئىككى دانەincrement ۋە get فۇنكىسيەسىنى قايتۇرىدۇ،بۇ فۇنكىسيەنىڭ ئىككىلىسى  counter نىڭ دائىرىسىگە(scope)غا بىر قوللانمىنى ساقلاپ قالىدۇ،شۇڭلاشقا count ئۆزگەرگۈچى مىقدارغائۆزى ئىنىقلانغان دائىرە ئىچىدە كىرگىلى بولىدۇ	
</p>
<p id="content">
	خۇسۇسى مىقدارنىڭ خىزمەت پىرىنسىپى
	</br>
 javascript دائىرەنى تەقسىملەش ياكى ئۇنى قوللانما قىلىش مۇمكىن بولمىغانلىقى ئۈچۈن،count  قا تىشىدىن كىرىشنىڭ ھىچقانداق چارىسى يوق،پەقەت ئۇنىڭ بىلەن ئالاقە قىلىش ئۇسۇلى بولسا ئىككى دانە closure ئارقىلىق بولىدۇ
</p>
<pre>
var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};</pre>
<p id="content">
	ئۈستىدىكى كود Counter نىڭ دائىرەسدىكى مىقدار count نى ئۆزگەرتمەيدۇ،چۈنكى ئۇ دائىرەدە  foo.hack ئىنىقلانمىغان،بۇنىڭ ئورنىدا بىر بولسا global دائىرلىك مىقدار  ئۈستى-ئۈستىلەپ يىزىلىدۇ ياكى قۇرۇلىدۇ
</p>
<p id="content">
loop نىڭ بەدىندىكى closure 
	</br>
	دائىم سادىر قىلنىدىغان خاتالىق بولساloops نىڭ ئىچىدە closure (چەكىلىمە)نى قوللىنىش

</p>
<pre>
for(var i = 0; i < 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}	
</pre>
<p id="content">
ئۈستىدىكى كود 0 دىن تارتىپ 9 غىچە قىممەت چىقارمايدۇ،بىراق 10 نى 10 قىتىم چىقىرىدۇ،نامسىز فۇنكىسيە i غا قارىتا قوللانمىنى ساقلاپ قالىدۇ،بۇ ۋاقىتتاconsole.log چاقىرىلىدۇ،for loop دەۋرىيلەش تاماملىنىدۇ ۋەi نىڭ قىممىتى 10 غا تەڭشىلىدۇ	
</p>
<p id="content">
قوللانما قىلىش مەسىسلىسدىن ساقلىنىش	
</p>
<pre>
for(var i = 0; i < 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}	
</pre>
<p id="content">
نامسىز سىرتقى فۇنكىسيە i بىلەن بىرگە ئۇنى بىرنجى پارامىتىر شەكلىدە دەرھاللا چاقىرلىدۇ،ئاندىن i نى ئۆزىنىڭ پارامىتىرى e شەكلىدە i نىڭ كۆچۈرۈلمىسىنى قۇبۇل قىلىدۇ
</br>
نامسىز فۇنكىسيەنىڭ setTimeout  قا ئۆتكۈزۈلگەن e غا قارىتا قوللانمىسى بولۇپ،بۇ قىممەتلەر loop تەرىپىدىن ئۆزگەرتىلمەيدۇ،بۇيەردە بۇخىل مەقسەتكە يىتىشنىڭ باشقىچە ئۇسۇللىرىمۇ بار،بۇنىڭ ئۇسۇلى بولسا بىر فۇنكىسيەنى نامسىز فۇنكىسيەدىن قايتۇرش بولۇپ،ئاندىن يۇقارقىدىكى كودتىكىگە ئوخشاش ئۈنۈمگە ئىرىشكىلى بولىدۇ
</p>
<pre>
for(var i = 0; i < 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}	
</pre>
<p id="content">
بۇيەردە يەنە bind ئىشلىتىپ مۇشۇ خىل مەقسەتكە يىتىشنىڭ ئۇسۇلى بار بولۇپ،بۇخىل ئۇسۇلدا this نىڭ كونتىكىستى ۋە پارامىتىرى فۇنكىسيەگە باغلىنىدۇ،ئاندىن يۇقاردىكى كودقا ئوخشاش نەتىجە ھاسىل بولىدۇ	
</p>
<pre>
for(var i = 0; i < 10; i++) {
    setTimeout(console.log.bind(console, i), 1000);
}	
</pre>
<p id="content">
arguments  ئوبيكىتى	
</br>
جاۋاسىكرىپتدىكى ھەربىر فۇنكىسيە دائىرىسى arguments دەپ ئاتالغان ئالاھىدە مىقدارغا كىرەلەيدۇ،بۇ مىقدار فۇنكىسيەگە ئۆتكۈزۈلگەن بارلىق arguments نىڭ تىزىملىكىنى كونترول قىلىدۇ
مۇھىتىم نوقتا شۇكى arguments نىڭ ئۆزى array (سانلار گۇرۇپپىسى ئەمەس)بىراق بۇمىقدارنىڭ array(سانلار گۇرۇپپىسنىڭكىگە)ئوخشاش length خاسلىقى بار،بۇ Array.prototype دىن ۋارسلىق قۇبۇل قىلمىغان بولۇپ،ئەمىليەتتە بۇ بىر ئوبيكىت ھىسابلىنىدۇ،مۇشۇ سەۋەبلىك ئۆلچەملىك سانلار گۇرۇپپىسى مىتودلىرىpush, pop ياكى slice نى arguments دا ئىشلەتكىلى بولمايدۇ
ئۆلچەملىك سانلار گۇرۇپپىسى مىتودىنى ئىشلىتىش ئۈچۈن arguments نى array غا ئايلاندۇرۇش كىرەك.ئاستىدكى بۇ كودarguments ئوبيكىتنىڭ بارلىق ئىلىمتلىرنى ئۆزئىىچگە ئالغان يڭى سانلار گۇرۇپپىسى(array)نى قايتۇرىدۇ
<pre>
Array.prototype.slice.call(arguments);
</pre>
</p>
<center>{{tormahiri}}</center>
</body>
